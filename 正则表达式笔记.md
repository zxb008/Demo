* 正则表达式:也叫规则表达式,按照一定的规则组成的一个表达式,这个表达式的作用主要是匹配字符串的,
    * "我的电话:10086,他的电话:10010,你的电话:10000" 正则表达式,把这个字符串中的所有的数字找到
    *
    * 正则表达式的作用:匹配字符串的
    *
    * 在大多数编程语言中都可以使用
    *
    * 正则表达式的组成:是由元字符或者是限定符组成的一个式子
    *
    *
    * 元字符:
    *
    * .  表示的是:除了\n以外的任意的一个字符   "fdsfs238"     \r代表回车(enter键)  \n代表换行
    *
    * [] 表示的是:范围,  [0-9] 表示的是0到9之间的任意的一个数字,  "789" [0-9]
      [2]   表示数字2
      [2aB]表示的是：数字2或者字母a或者字母B
    * [1-7] 表示的是1到7之间的任意的一个数字 
      注意： 如果要表达100到200之间的任意数子 错误写法:[100-200]  正确写法: [1][0-9][0-9]
                                                                最小值： 1    0    0
      
                                                                最大值： 1    9    9
    * [a-z] 表示的是:所有的小写的字母中的任意的一个
    * [A-Z] 表示的是:所有的大写的字母中的任意的一个
      [0-9x] 表示的是：0到9中的任意一个数字或者字母x
    * [a-zA-Z] 表示的是:所有的字母的任意的一个
    * [0-9a-zA-Z] 表示的是: 所有的数字或者是字母中的一个
      [0-9a-zA-Z_.-] 表示的是0到9中的任意一个数字或者a到z的任意一个字母或者A到Z的任意一个字母或者下划线_或者字符.或者字符—
    * [] 另一个函数: 把正则表达式中元字符的意义干掉    [.] 就是一个.
    * |  或者     [0-9]|[a-z] 表示的是要么是一个数字,要么是一个小写的字母 等价： [0-9a-z]
    * () 1.提升优先级 2.分组  
         提升优先级： [0-9]|([a-z])|[A-Z]  先承认小括号里面的a-z中任意一个字母
    *    分组： (()(()))  四组，从左边开始数有几个'('
                [0-9][a-f]|[A-Y][7-9]   和 ([0-9][a-f])|([A-Y][7-9]) 是不同的表达意思，前者是3位，后者是2位
    * 
    *
    *
    * 都是元字符,但是也可以叫限定符,下面的这些
    *    *   表示的是:前面的表达式出现了0次到多次
    *    [a-z][0-9]* 小写字母中的任意一个 后面是要么是没有数字的,要么是多个数字的
    *    "fdsfs3223323"  [a-z][0-9]* => 正则表达式匹配了字符串中一部分
    *
    *    +  表示的是:前面的表达式出现了1次到多次
    *    [a-z][9]+  小写字母一个后面最少一个9,或者多个9
    *    "fesfewww9fefds"
    *
    *    ?  表示的是:前面的表达式出现了0次到1次,最少是0次,最多1次 ,另一个含义:阻止贪婪模式
    *    [4][a-z]? "1231234ij"
    *  限定符:限定前面的表达式出现的次数
    *  {} 更加的明确前面的表达式出现的次数
    *  {0,} 表示的是前面的表达式出现了0次到多次,和 *一样的
    *  {1,} 表示的是前面的表达式出现了1次到多次,和 +一样的
    *  {0,1} 表示的是前面的表达式出现了0次到1次,和 ?一样的
    *  {5,10} 表示的是前面的表达式出现了5次到10次
    *  {4} 前面的表达式出现了4次
    *  {,10} 错误的========不能这么写
    *  ^ 表示的是以什么开始,或者是取非(取反) 
       ^[0-9] 以数字开头
    *  ^[a-z] 以小写字母开始
    *  [^0-9] 取反,非数字
    *  [^a-z] 非小写字母
    *  [^0-9a-zA-Z_] 表示键盘上面剩下的特殊符号
    *  $ 表示的是以什么结束   [0-9][a-z]$  必须以小写字母结束
    *  ^[0-9][a-z]$ 相当于是严格模式   "3f2432e"不能匹配  "4f"能匹配
    *   \d 数字中的任意一个,等价[0-9]  但是和[4-8]这种不是一样的
    *   \D 非数字中的一个,等价[^0-9]
    *   \s 空白符中的一个
    *   \S 非空白符
    *   \w 非特殊符号
    *   \W 特殊符号
    *   \b	匹配一个单词边界，即字与空格间的位置
        \B	非单词边界匹配
    *   "what are you no sha lei"
        \ 表示转义字符,  /?/  匹配不了 123?132  因为在正则表达式里面?是元字符,需要： /\?/ 来匹配  123?456  
        其他的元字符也是一样的

        \cx	匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
        \f	匹配一个换页符。等价于 \x0c 和 \cL。
        \n	匹配一个换行符。等价于 \x0a 和 \cJ。
        \r	匹配一个回车符。等价于 \x0d 和 \cM。
        \s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
        \S	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
        \t	匹配一个制表符。等价于 \x09 和 \cI。
        \v	匹配一个垂直制表符。等价于 \x0b 和 \cK。


 * 写正则表达式,根据字符串来写正则表达式进行匹配
    *
    * 经验: 1.找规律 2.不要追求完美
    *
    *
    * 身份证的正则表达式
    *
    * 15位或者18位
    * ([1-9][0-9]{14})|([1-9][0-9]{16}[0-9xX])
    *    思考两边都带()的作用：分组。如果没有(),那么将会是靠近|两边的元字符取一个
    *
    * ([1-9][0-9]{14})([0-9]{2}[0-9xX])?
    *     15位          3位要么出现0次，要么出现1次
    *
    * 练习:
    * 1.座机号码的正则表达式
    * 010-19876754   
    * 0431-87123490
    *
    * [0-9]{3,4}[-][0-9]{8}
    * \d{3,4}[-]\d{8}
    *
    * \d{3,4}[-][0-9]{8}
    *
    *
    * 2.qq号码的正则表达式
    *
    * [1-9][0-9]{4,10}
    * \d{5,11}
    *
    * 3.手机号码的正则表达式
    *
    * 130 131 132 133 134 135 136 137 138 139
    * 143 147
    * 150 151 152 153 154 155 156 157 158 159
    * 170 171 173 176 177
    * 180 181 182 183 184 185 186 187 188 189
    * ([1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})
    * \d{11}
    *
    *
    * 邮箱的正则表达式,必须要记住的
    *
    * sd2113_3.-fd@itcast.com.cn
    *
    *
    *
    * [0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2}


    

正则表达式对象 ：
    //构造函数方法
    var reg=new RegExp(/\d{5}/);
    //调用方法验证字符串是否匹配
    var flag=reg.test("我的电话是10086");
    console.log(flag);


    //字面量的方式创建正则表达式对象
    var reg=/\d{1,5}/;
    var flag=reg.test("小苏的幸运数字:888");
    console.log(flag);

    正则表达式对象的方法：
    .test() 检测字符串是否匹配正则表达式，匹配返回true ，不匹配返回false
      var flag = /\d/.test("998小占")   //flag为true，因为这是非严格模式，\d代表数字，能够匹配到字符串中的数字
    .exec()  检测字符串是否匹配正则表达式，将匹配的结果返回一个数组，没有的话，返回null
      var str="中国移动:10086,中国联通:10010,中国电信:10000";
      var array=/\d{5}/g.exec(str);   //array为一个数组：[10086,10010,10000]

      说明：正则表达式.exec()与下面字符串的方法.match()作用是一样的。另外，字符串也有好多方法涉及到正则表达式
       var str="中国移动:10086,中国联通:10010,中国电信:10000";
       //把里面所有的数字全部显示出来
       var array=str.match(/\d{5}/g); //array为一个数组：[10086,10010,10000]
